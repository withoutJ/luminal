(ruleset expr)
(ruleset cleanup)
(ruleset early)

; -------- SYMBOLIC ALGEBRA -------
(datatype*
    (Expression
        (MNum i64)
        (MFloat f64)
        (MIter)
        (MVar String)
        (MAdd Expression Expression)
        (MSub Expression Expression)
        (MMul Expression Expression)
        (MCeilDiv Expression Expression)
        (MDiv Expression Expression)
        (MMod Expression Expression)
        (MMin Expression Expression)
        (MMax Expression Expression)
        (MAnd Expression Expression)
        (MOr  Expression Expression)
        (MGte Expression Expression)
        (MLt  Expression Expression)
        (MFloorTo Expression Expression)
        (MReplace Expression Expression Expression)
    )

    ; eqsort list for vectors of Expression
    (EList
        (ECons Expression EList)
        (ENil)
        (MReplaceList EList Expression Expression)
        (ReplaceNthFromEnd EList Expression i64)
        (RemoveNthFromEnd EList i64)
        (RowMajor EList)
    )

    (DType
        (F32)
        (F16)
        (Bf16)
        (Int)
        (Bool)
        (NvFp4)
        (Mxfp4)
    )
)

; ---- Algebraic rewrites ----
;(rewrite (MAdd a b) (MAdd b a) :ruleset expr) ; communativity leads to some explosions
(rewrite (MMul a b) (MMul b a) :ruleset expr)

;(rewrite (MAdd (MAdd a b) c) (MAdd a (MAdd b c)) :ruleset expr) ; explodes weirdly, see no_explode test in symbolic.rs
;(rewrite (MMul (MMul a b) c) (MMul a (MMul b c)) :ruleset expr)

(rule ((= ?e (MAdd (MNum a) (MNum b))) (= ?ans (+ a b))) ((union ?e (MNum ?ans)) (subsume (MAdd (MNum a) (MNum b)))) :ruleset expr)
(rewrite (MSub (MNum a) (MNum b)) (MNum (- a b)) :ruleset expr)
; multiply const folding
(rule
    (
        (= ?e (MMul (MNum ?a) (MNum ?b)))
        (= ?prod (* ?a ?b))
    )
    (
        (union ?e (MNum ?prod))
        (subsume (MMul (MNum ?a) (MNum ?b)))
    )
    :ruleset expr
)
(rewrite (MDiv (MNum a) (MNum b)) (MNum (/ a b)) :when ((!= 0 b) (= 0 (% a b))) :ruleset expr)
(rewrite (MCeilDiv (MNum a) (MNum b)) (MNum (/ a b)) :when ((!= 0 b) (= 0 (% a b))) :ruleset expr)
(rewrite (MMax (MNum a) (MNum b)) (MNum (max a b)) :ruleset expr)
(rewrite (MMin (MNum a) (MNum b)) (MNum (min a b)) :ruleset expr)
(rewrite (MAnd (MNum a) (MNum b)) (MNum (& a b)) :ruleset expr)
(rewrite (MFloat -1.0) (MNum -1) :ruleset expr)
(rewrite (MNum -1) (MFloat -1.0) :ruleset expr)
;(rewrite (MDiv (MMul ?x (MNum ?a)) (MNum ?b)) (MMul ?x (MNum (/ ?a ?b))) :when ((< ?b ?a) (= (% ?a ?b) 0)) :ruleset expr) ; why does this explode???

(rewrite (MAdd a (MNum 0)) a :ruleset expr)
(rule ((= ?e (MMul ?a (MNum 1)))) ((union ?e ?a)) :ruleset expr)
(rule ((= ?e (MMul ?a (MNum 0)))) ((union ?e (MNum 0)) (subsume (MMul ?a (MNum 0)))) :ruleset expr)
(rewrite (MDiv a (MNum 1)) a :ruleset expr)
(rewrite (MMod (MMul ?x ?y) ?y) (MNum 0) :ruleset expr)
(rewrite (MMod (MMod ?x (MNum ?y)) (MNum ?z)) (MMod ?x (MNum ?y))
         :when ((>= ?z ?y) (= 0 (% ?y ?z))) :ruleset expr)
(rewrite (MMod (MMod ?x (MNum ?y)) (MNum ?z)) (MMod ?x (MNum ?z))
         :when ((>= ?y ?z) (= 0 (% ?z ?y))) :ruleset expr)
(rewrite (MDiv (MDiv a b) c) (MDiv a (MMul b c)) :ruleset expr)
(rewrite (MAdd (MDiv a b) c) (MDiv (MAdd a (MMul c b)) b) :ruleset expr)
(rewrite (MAdd a (MSub b a)) b :ruleset expr)
(rewrite (MAdd (MSub b a) a) b :ruleset expr)
(rewrite (MSub a a) (MNum 0) :ruleset expr)
(rewrite (MAdd (MSub a (MNum ?b)) (MNum ?c)) (MSub a (MNum (- ?b ?c))) :ruleset expr)
(rewrite (MAdd (MNum ?c) (MSub a (MNum ?b))) (MSub a (MNum (- ?b ?c))) :ruleset expr)
(rewrite (MSub (MAdd a (MNum ?b)) (MNum ?c)) (MAdd a (MNum (- ?b ?c))) :ruleset expr)
(rewrite (MSub (MSub a (MNum ?b)) (MNum ?c)) (MSub a (MNum (+ ?b ?c))) :ruleset expr)
(rewrite (MAdd (MMul a b) (MMul a c)) (MMul a (MAdd b c)) :ruleset expr)
(rewrite (MAdd a a) (MMul (MNum 2) a) :ruleset expr)

; Simplify (a/b)*c -> a/(b/c) when c divides b TODO: Not allowed because of integer division.
;(rewrite (MMul (MDiv ?a (MNum ?b)) (MNum ?c)) (MDiv ?a (MNum (/ ?b ?c))) :when ((= 0 (% ?b ?c))) :ruleset expr)
;(rewrite (MMul (MNum ?c) (MDiv ?a (MNum ?b))) (MDiv ?a (MNum (/ ?b ?c))) :when ((= 0 (% ?b ?c))) :ruleset expr)
;(rewrite (MMul (MMul ?a (MDiv ?x (MNum ?b))) (MNum ?c)) (MMul ?a (MDiv ?x (MNum (/ ?b ?c)))) :when ((= 0 (% ?b ?c))) :ruleset expr)
;(rewrite (MMul (MMul (MDiv ?x (MNum ?b)) ?a) (MNum ?c)) (MMul (MDiv ?x (MNum (/ ?b ?c))) ?a) :when ((= 0 (% ?b ?c))) :ruleset expr)

; Constant folding through associativity: ((a + c1) + c2) -> (a + (c1+c2))
(rule ((= ?e (MAdd (MAdd ?a (MNum ?b)) (MNum ?c))) (= ?ans (+ ?b ?c))) ((union ?e (MAdd ?a (MNum ?ans))) (subsume (MAdd (MAdd ?a (MNum ?b)) (MNum ?c)))) :ruleset expr)
(rewrite (MAdd (MAdd (MNum ?b) (MVar ?v)) (MNum ?c)) (MAdd (MVar ?v) (MNum (+ ?b ?c))) :ruleset expr)
(rewrite (MAdd (MAdd (MNum ?b) (MMul ?n ?a)) (MNum ?c)) (MAdd (MMul ?n ?a) (MNum (+ ?b ?c))) :ruleset expr)

; Combine like terms: (n*a) + a -> (n+1)*a
(rewrite (MAdd (MMul (MNum ?n) ?a) ?a) (MMul (MNum (+ ?n 1)) ?a) :subsume :ruleset expr)
(rewrite (MAdd ?a (MMul (MNum ?n) ?a)) (MMul (MNum (+ ?n 1)) ?a) :subsume :ruleset expr)
(rewrite (MAdd (MMul ?a (MNum ?n)) ?a) (MMul (MNum (+ ?n 1)) ?a) :subsume :ruleset expr)
(rewrite (MAdd ?a (MMul ?a (MNum ?n))) (MMul (MNum (+ ?n 1)) ?a) :subsume :ruleset expr)

; Combine repeated variables: ((a + v) + v) -> (a + 2*v)
(rewrite (MAdd (MAdd ?a (MVar ?v)) (MVar ?v)) (MAdd ?a (MMul (MNum 2) (MVar ?v))) :subsume :ruleset expr)
(rewrite (MAdd (MAdd (MVar ?v) ?a) (MVar ?v)) (MAdd ?a (MMul (MNum 2) (MVar ?v))) :subsume :ruleset expr)

; Accumulate: ((n*a + b) + a) -> ((n+1)*a + b)
(rewrite (MAdd (MAdd (MMul (MNum ?n) ?a) ?b) ?a) (MAdd (MMul (MNum (+ ?n 1)) ?a) ?b) :subsume :ruleset expr)
(rewrite (MAdd (MAdd ?b (MMul (MNum ?n) ?a)) ?a) (MAdd ?b (MMul (MNum (+ ?n 1)) ?a)) :subsume :ruleset expr)

; ---- Replacement over expressions ----
(rewrite (MReplace ?x ?y ?z) ?z :when ((= ?x ?y)) :ruleset expr)
(rewrite (MReplace (MAdd ?a ?b) ?x ?y) (MAdd (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MSub ?a ?b) ?x ?y) (MSub (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MMul ?a ?b) ?x ?y) (MMul (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MDiv ?a ?b) ?x ?y) (MDiv (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MCeilDiv ?a ?b) ?x ?y) (MCeilDiv (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MMod ?a ?b) ?x ?y) (MMod (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MMin ?a ?b) ?x ?y) (MMin (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MMax ?a ?b) ?x ?y) (MMax (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MFloorTo ?a ?b) ?x ?y) (MFloorTo (MReplace ?a ?x ?y) (MReplace ?b ?x ?y)) :ruleset expr)
(rewrite (MReplace (MNum ?n) ?x ?y) (MNum ?n) :ruleset expr)
(rewrite (MReplace (MVar ?z) ?find ?replace) (MVar ?z) :when ((!= ?find (MVar ?z))) :ruleset expr)
(rewrite (MReplace (MIter) ?find ?replace) (MIter) :when ((!= ?find (MIter))) :ruleset expr)

; EList helper functions
(function len (EList) i64 :merge new)
(rule ((= ?e (ENil))) ((set (len ?e) 0)) :ruleset expr)
(rule ((= ?e (ECons ?expr ?list)) (= ?prev_len (len ?list))) ((set (len ?e) (+ ?prev_len 1))) :ruleset expr)

(function nth_from_end (EList i64) Expression :merge new)
(rule ((= ?e (ECons ?expr ?list)) (= ?list_len (len ?list))) ((set (nth_from_end ?e ?list_len) ?expr)) :ruleset expr)
(rule ((= ?e (ECons ?expr ?list)) (= ?other_nth (nth_from_end ?list ?n))) ((set (nth_from_end ?e ?n) ?other_nth)) :ruleset expr)

(function n_elements (EList) Expression :merge new)
(rule ((= ?e (ENil))) ((set (n_elements ?e) (MNum 1))) :ruleset expr)
(rule
 	(
     	(= ?e (ECons ?dim ?other))
     	(= ?other_elems (n_elements ?other))
    )
 	((set (n_elements ?e) (MMul ?dim ?other_elems)))
 	:ruleset expr
)

(rule
    (
     	(= ?other (ECons ?other_dim ?other_other))
        (= ?list (ECons ?d ?other))
        (= ?e (RowMajor ?list))
        (= ?n_elems (n_elements ?other))
    )
    (
        (union ?e (ECons ?n_elems (RowMajor ?other)))
    )
    :ruleset expr
)
(rewrite (RowMajor (ECons ?dim (ENil))) (ECons (MNum 1) (ENil)) :ruleset expr)

(rewrite (MReplaceList (ECons ?expr ?list) ?from ?to) (ECons (MReplace ?expr ?from ?to) (MReplaceList ?list ?from ?to)) :ruleset expr)
(rule
    (
        (= ?e (ReplaceNthFromEnd (ECons ?expr ?list) ?to ?ind))
        (= ?ind (len ?list))
    )
    (
        (union ?e (ECons ?to ?list))
    )
    :ruleset expr
)
(rule
    (
        (= ?e (ReplaceNthFromEnd (ECons ?expr ?list) ?to ?ind))
        (< ?ind (len ?list))
    )
    (
        (union ?e (ECons ?expr (ReplaceNthFromEnd ?list ?to ?ind)))
    )
    :ruleset expr
)
(rule
    (
        (= ?e (RemoveNthFromEnd (ECons ?expr ?list) ?ind))
        (= ?ind (len ?list))
    )
    (
        (union ?e ?list)
    )
    :ruleset expr
)
(rule
    (
        (= ?e (RemoveNthFromEnd (ECons ?expr ?list) ?ind))
        (< ?ind (len ?list))
    )
    (
        (union ?e (ECons ?expr (RemoveNthFromEnd ?list ?ind)))
    )
    :ruleset expr
)
