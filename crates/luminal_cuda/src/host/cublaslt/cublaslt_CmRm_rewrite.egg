; Column-major × Row-major matmul: C[m,n] = A[m,k] × B[k,n]
; A[m,k] column-major → expand to [m, n, k] with strides [1, 0, m]
; B[k,n] row-major → permute to [n,k] then expand to [m, n, k] with strides [0, 1, n]
;
; Row-major viewed as column-major (swap trick):
;   Column-major A[m,k] is already column-major with lda=m
;   Row-major B[k,n] ≡ column-major B^T[n,k] with ldb=n
;   Row-major C[m,n] ≡ column-major C^T[n,m] with ldc=n
;
; C^T[n,m] = (A × B)^T = B^T[n,k] × A^T[k,m]
; cuBLAS: cublasSgemm(OP_N, OP_T, n, m, k, α, B, n, A, m, β, C, n)
(rule
    (
        ; Match Mul node
        (= ?mul (Mul ?mul_shape ?a ?a_stride ?b ?b_stride ?mul_out_stride))

        ; Match Sum that reduces the Mul (k dimension)
        (= ?sum (Sum ?out_shape ?k ?mul ?sum_in_stride ?k_stride ?sum_out_stride))

        ; Get dimensions from output shape
        (= ?m (nth_from_end ?out_shape 1))
        (= ?n (nth_from_end ?out_shape 0))
        (!= ?m (MNum 0))
        (!= ?n (MNum 0))

        ; Get A strides in [m, n, k] space
        (= ?a_m_stride (nth_from_end ?a_stride 2))
        (= ?a_n_stride (nth_from_end ?a_stride 1))
        (= ?a_k_stride (nth_from_end ?a_stride 0))

        ; Get B strides in [m, n, k] space
        (= ?b_m_stride (nth_from_end ?b_stride 2))
        (= ?b_n_stride (nth_from_end ?b_stride 1))
        (= ?b_k_stride (nth_from_end ?b_stride 0))

        ; Assert contiguous k stride on output (required for reduction)
        (= ?k_stride (MNum 1))

        ; Assert A has strides [1, 0, m] (column-major A[m,k] broadcast to [m,n,k])
        (= ?a_m_stride (MNum 1))
        (= ?a_n_stride (MNum 0))
        (= ?a_k_stride ?m)

        ; Assert B has strides [0, 1, n] (row-major B[k,n] permuted to [n,k] then broadcast to [m,n,k])
        (= ?b_m_stride (MNum 0))
        (= ?b_n_stride (MNum 1))
        (= ?b_k_stride ?n)

        (= ?dt (dtype ?a))
        (= ?dt (dtype ?b))
    )
    (
        ; For column-major A × row-major B with cuBLAS:
        ; C^T = B^T × A^T → cublasSgemm(OP_N, OP_T, n, m, k, α, B, n, A, m, β, C, n)
        (let ?sgemm (cublaslt
            ?b             ; First matrix = B (swapped)
            ?a             ; Second matrix = A (swapped)
            ?n             ; cuBLAS m = our n (swapped)
            ?m             ; cuBLAS n = our m (swapped)
            ?k             ; k unchanged
            "N"            ; transa = No transpose (B is row-major, viewed as col-major [n,k])
            "T"            ; transb = Transpose (A is column-major [m,k], need A^T[k,m])
            ?n             ; lda = n (row-major B[k,n] viewed as col-major [n,k])
            ?m             ; ldb = m (column-major A[m,k])
            ?n             ; ldc = n (row-major C[m,n] viewed as col-major [n,m])
            ?dt))          ; dtype
        (union ?sum ?sgemm)
        (set (dtype ?sgemm) ?dt)
    )
    :name "cublaslt column-major × row-major"
)
