; Row-major × Column-major matmul: C[m,n] = A[m,k] × B[k,n]
; A[m,k] row-major → expand to [m, n, k] with strides [k, 0, 1]
; B[k,n] column-major → expand to [m, n, k] with strides [0, k, 1]
;
; Row-major viewed as column-major (swap trick):
;   Row-major A[m,k] ≡ column-major A^T[k,m] with lda=k
;   Column-major B[k,n] is already column-major with ldb=k
;   Row-major C[m,n] ≡ column-major C^T[n,m] with ldc=n
;
; C^T[n,m] = (A × B)^T = B^T[n,k] × A^T[k,m]
; cuBLAS: cublasSgemm(OP_T, OP_N, n, m, k, α, B, k, A, k, β, C, n)
(rule
    (
        ; Match Mul node
        (= ?mul (Mul ?mul_shape ?a ?a_stride ?b ?b_stride ?mul_out_stride))

        ; Match Sum that reduces the Mul (k dimension)
        (= ?sum (Sum ?out_shape ?k ?mul ?sum_in_stride ?k_stride ?sum_out_stride))

        ; Get dimensions from output shape
        (= ?m (nth_from_end ?out_shape 1))
        (= ?n (nth_from_end ?out_shape 0))
        (!= ?m (MNum 0))
        (!= ?n (MNum 0))

        ; Get A strides in [m, n, k] space
        (= ?a_m_stride (nth_from_end ?a_stride 2))
        (= ?a_n_stride (nth_from_end ?a_stride 1))
        (= ?a_k_stride (nth_from_end ?a_stride 0))

        ; Get B strides in [m, n, k] space
        (= ?b_m_stride (nth_from_end ?b_stride 2))
        (= ?b_n_stride (nth_from_end ?b_stride 1))
        (= ?b_k_stride (nth_from_end ?b_stride 0))

        ; Assert contiguous k stride on output (required for reduction)
        (= ?k_stride (MNum 1))

        ; Assert A has strides [k, 0, 1] (row-major A[m,k] broadcast to [m,n,k])
        (= ?a_m_stride ?k)
        (= ?a_n_stride (MNum 0))
        (= ?a_k_stride (MNum 1))

        ; Assert B has strides [0, k, 1] (column-major B[k,n] broadcast to [m,n,k])
        (= ?b_m_stride (MNum 0))
        (= ?b_n_stride ?k)
        (= ?b_k_stride (MNum 1))

        (= ?dt (dtype ?a))
        (= ?dt (dtype ?b))
    )
    (
        ; For row-major A × column-major B with cuBLAS:
        ; C^T = B^T × A^T → cublasSgemm(OP_T, OP_N, n, m, k, α, B, k, A, k, β, C, n)
        (let ?sgemm (cublaslt
            ?b             ; First matrix = B (swapped)
            ?a             ; Second matrix = A (swapped)
            ?n             ; cuBLAS m = our n (swapped)
            ?m             ; cuBLAS n = our m (swapped)
            ?k             ; k unchanged
            "T"            ; transa = Transpose (B is column-major, need B^T)
            "N"            ; transb = No transpose
            ?k             ; lda = k (column-major B[k,n])
            ?k             ; ldb = k (row-major A[m,k] viewed as col-major [k,m])
            ?n             ; ldc = n (row-major C[m,n] viewed as col-major [n,m])
            ?dt))          ; dtype
        (union ?sum ?sgemm)
        (set (dtype ?sgemm) ?dt)
    )
    :name "cublaslt row-major × column-major"
)